


# 二.字符串专题

-----------------------------
##### 125.验证回文串
>题目描述：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
说明：本题中，我们将空字符串定义为有效的回文串。
示例 1:
输入: "A man, a plan, a canal: Panama"
输出: true

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/valid-palindrome

解题思路：双指针法不断向中间靠拢即可。

>此处需要使用一些C的函数，如
**isdigit** :判断是否为数字
**isalpha** : 判断是否为字母，大小写均可
**isalnum** : 判断是否为字母或数字
**isupper** : 判断字母是否为大写
**islower** : 判断字母是否为小写
**isspace** : 是否为空格
**isblank** : 是否为空白
**tolower** : 将大写字母转为小写
**toupper** : 将小写字母转为大写

时间复杂度：O(N)

空间复杂度：O(1)

```cpp
class Solution {
public:
    bool isPalindrome(string s) {
        if (s.empty())
            return true;
        int i = 0, j = s.size()-1;
        while (i < j)
        {
            while (i < j && !isalnum(s[i]))
                i++;
            while (i < j && !isalnum(s[j]))
                j--;
            if (i < j && tolower(s[i++])!=tolower(s[j--]))
                return false;
        }
        return true;
    }
};

```

<br>

-----------------------------
##### 28.实现strStr()
>题目描述：实现 strStr() 函数。
给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。
示例 1:
输入: haystack = "hello", needle = "ll"
输出: 2
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/implement-strstr

* **解法一**

解题思路：BF暴力法，从每一个haystack的元素开始遍历，往后看是否满足 needle字符串。该方法超时！

时间复杂度：O(N*M)

空间复杂度：O(1)

```cpp

```

* **解法二**

解题思路：RK算法，首先对needle进行哈希求值并求出长度n，再对haystack进行一次遍历并在haystack中不断计算n长度的哈希值，若haystakc和needle的哈希值相等时，需要进行一遍对比（因为可能会出现哈希冲突的情况），如果仍然相等则说明两个字符串匹配。
RK算法的缺点就是如果哈希冲突太多的话，就会退化成BF算法，这个也很好理解。


时间复杂度：O(M+N)

空间复杂度：O(1)


```cpp
class Solution {
public:
    int strStr(string haystack, string needle) {
        int sum1 = 0, sum2 = 0, len1 = haystack.size(), len2 = needle.size();
        for (auto& e: needle)
            sum2 += e;
        int start = 0, end = len2-1;
        for (int i = start; i <= end; i++)
            sum1 += haystack[i];
        while (end < len1)
        {
            if (sum1 == sum2)
            {
                bool flag = true;//预防哈希冲突
                for (int i = 0; i < len2; i++)
                    if (haystack[i+start] != needle[i])
                    {
                        flag = false;
                        break;
                    }
                if (flag)
                   return start;
            }
            end++;
            start++;
            if (end < len1)
                sum1 = sum1 + haystack[end]-haystack[start-1];
        }
        return -1;
    }
};

```

* **解法三**

解题思路：KMP算法，在haystack设置永不回退的指针i，在needle上设置动态回退的指针j，其中需要辅助数组next，每一次匹配失败时，**j = next[j]** ，也就是回退到之前已经拥有重复前缀的位置。
next数组其实也很好理解，需要用到动态规划的思想。它根据 前缀的前一部分 和 前缀的后一部分 是否相等，用来记录匹配失败时j指针需要回退的位置。因为如果 前缀的后一部分 能够匹配成功，那么 前缀的后一部分 也能够匹配成功，也就无需再一次让 j 指针从头开始，这就是next 数组的原理。

时间复杂度：O(M+N)

空间复杂度：O(N)

```cpp


```



<br>


-----------------------------
##### 8.字符串转换整数
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 67.二进制求和
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 5.最长回文子串
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 10.正则表达式匹配
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 44.通配符匹配
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 14.最长公共前缀
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 65.有效数字
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 12.整形转罗马数字
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 13.罗马数字转整形
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 38.外观数列
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 49.字母异位词分组
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 71.简化路径
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>


-----------------------------
##### 58.最后一个单词的长度
>题目描述：

解题思路：

时间复杂度：

空间复杂度：

```cpp

```

<br>

